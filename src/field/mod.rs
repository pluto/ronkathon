use std::{
  hash::Hash,
  iter::{Product, Sum},
  ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Rem, Sub, SubAssign},
};

pub mod gf_101;

/// A field is a set of elements on which addition, subtraction, multiplication, and division are
/// defined.
///
/// We restrict to finite fields, which are fields with a finite number of elements.
pub trait FiniteField:
  std::fmt::Debug
  + Sized
  + Copy
  + Clone
  + PartialEq
  + Eq
  + Add<Output = Self>
  + AddAssign
  + Sum
  + Sub<Output = Self>
  + SubAssign
  + Mul<Output = Self>
  + MulAssign
  + Product
  + Div<Output = Self>
  + DivAssign
  + Neg<Output = Self>
  + Rem<Output = Self>
  + Hash
  + 'static {
  type Storage: From<u32>
    + Copy
    + std::fmt::Debug
    + Sub<Output = Self::Storage>
    + Div<Output = Self::Storage>
    + Rem<Output = Self::Storage>
    + Eq;
  const ORDER: Self::Storage;
  fn zero() -> Self;
  fn one() -> Self;
  fn two() -> Self;
  fn neg_one() -> Self;
  fn inverse(&self) -> Option<Self>;
  fn pow(&self, power: Self::Storage) -> Self;
  fn generator() -> Self;

  // In any field of prime order F_p:
  // - There exists an additive group.
  // - There exists a multiplicative subgroup generated by a primitive element 'a'.
  //
  // According to the Sylow theorems (https://en.wikipedia.org/wiki/Sylow_theorems):
  // A non-trivial multiplicative subgroup of prime order 'q' exists if and only if
  // 'p - 1' is divisible by 'q'.
  // The primitive q-th root of unity 'w' is defined as: w = a^((p - 1) / q),
  // and the roots of unity are generated by 'w', such that {w^i | i in [0, q - 1]}.
  fn primitive_root_of_unity(n: Self::Storage) -> Self {
    let p_minus_one = Self::ORDER - Self::Storage::from(1);
    assert!(p_minus_one % n == 0.into(), "n must divide p - 1");
    let pow = p_minus_one / n;
    Self::generator().pow(pow)
  }
}
