use serde::{Deserialize, Serialize};

use super::*;

pub mod gf_101;
pub mod gf_101_2;

/// A field is a set of elements on which addition, subtraction, multiplication, and division are
/// defined.
///
/// We restrict to finite fields, which are fields with a finite number of elements.
pub trait FiniteField:
  std::fmt::Debug
  + Default
  + Sized
  + Copy
  + Clone
  + PartialEq
  + Eq
  + Add<Output = Self>
  + AddAssign
  + Sum
  + Sub<Output = Self>
  + SubAssign
  + Mul<Output = Self>
  + MulAssign
  + Product
  + Div<Output = Self>
  + DivAssign
  + Neg<Output = Self>
  + Rem<Output = Self>
  + Hash
  + 'static {
  type Storage: From<u32>
    + Into<u32>
    + Into<u64>
    + Copy
    + std::fmt::Debug
    + Sub<Output = Self::Storage>
    + Div<Output = Self::Storage>
    + Rem<Output = Self::Storage>
    + Mul<Output = Self::Storage>
    + Eq;
  const ORDER: Self::Storage;
  const ZERO: Self;
  const ONE: Self;
  const TWO: Self;
  const NEG_ONE: Self;
  const THREE: Self;

  fn inverse(&self) -> Option<Self>;
  fn from_canonical_u32(n: u32) -> Self;
  fn generator() -> Self;
  fn double(&self) -> Self { *self + *self }
  fn square(&self) -> Self { *self * *self }

  fn pow(&self, mut power: u64) -> Self {
    let mut current = *self;
    let mut product = Self::ONE;

    while power > 0 {
      if power % 2 == 1 {
        product *= current;
      }
      current = current * current;
      power /= 2;
    }

    product
  }

  // In any field of prime order F_p:
  // - There exists an additive group.
  // - There exists a multiplicative subgroup generated by a primitive element 'a'.
  //
  // According to the Sylow theorems (https://en.wikipedia.org/wiki/Sylow_theorems):
  // A non-trivial multiplicative subgroup of prime order 'n' exists if and only if
  // 'p - 1' is divisible by 'n'.
  // The primitive n-th root of unity 'w' is defined as: w = a^((p - 1) / n),
  // and the roots of unity are generated by 'w', such that {w^i | i in [0, n - 1]}.
  fn primitive_root_of_unity(n: Self::Storage) -> Self {
    let p_minus_one = Self::ORDER - Self::Storage::from(1);
    assert!(p_minus_one % n == 0.into(), "n must divide p - 1");
    let pow = p_minus_one / n;
    Self::generator().pow(pow.into())
  }
}

#[const_trait]
pub trait ExtensionField<B: FiniteField>:
  FiniteField
  + From<B>
  + Add<B, Output = Self>
  + AddAssign<B>
  + Sub<B, Output = Self>
  + SubAssign<B>
  + Mul<B, Output = Self>
  + MulAssign<B> {
  const D: usize;
  fn irreducible() -> B;
  fn from_base(base: B) -> Self;
}

// algorithm to compute primitive element of field (multiplicative generator)
pub fn get_generator(p: u32) -> i32 {
  let mut fact = Vec::new();
  let phi = p - 1;
  let mut n = phi;
  let mut i = 2;
  while i * i <= n {
    if n % i == 0 {
      fact.push(i);
      while n % i == 0 {
        n /= i;
      }
    }
    i += 1;
  }
  if n > 1 {
    fact.push(n);
  }

  for res in 2..=p {
    let mut ok = true;
    for &f in &fact {
      ok &= powmod(res, phi / f, p) != 1;
      if !ok {
        break;
      }
    }
    if ok {
      return res as i32;
    }
  }
  -1
}

fn powmod(base: u32, exponent: u32, modulus: u32) -> u32 {
  let mut base = base as u64;
  let mut exponent = exponent;
  let modulus = modulus as u64;
  let mut result = 1;
  base %= modulus;
  while exponent > 0 {
    if exponent % 2 == 1 {
      result = (result * base) % modulus;
    }
    base = (base * base) % modulus;
    exponent >>= 1;
  }
  result as u32
}
