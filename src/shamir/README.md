# Shamir's Secret Sharing Scheme

Shamir’s Secret Sharing (SSS) is a cryptographic scheme used to divide a secret into multiple parts called *shares*. In an SSS system, the secret is split into **n** shares, where any **k** (with *k ≤ n*) of these shares are required to reconstruct the original secret. This is why SSS is often referred to as a *k-out-of-n* secret sharing scheme.

## Concept and Mathematical Foundation

The scheme is based on the fact that **k** points uniquely determine a polynomial of degree **k - 1** over a finite field. The main ideas involved are:

- **Polynomial Construction:**  
  The secret is encoded as the constant term `a₀` of a random polynomial:  
  `P(x) = a₀ + a₁x + a₂x² + ... + aₖ₋₁x^(k-1)`  
  where the coefficients `a₁, a₂, ..., aₖ₋₁` are randomly chosen from a finite field.

- **Evaluation at Distinct Points:**  
  Each share is generated by evaluating the polynomial at a unique and nonzero value `x`. A share is a tuple `(x, P(x))`.

- **Reconstruction via Lagrange Interpolation:**  
  Given any **k** shares, the original polynomial can be recovered (and thus the secret retrieved) using Lagrange interpolation. This process uses the shares to reconstruct the constant term of the polynomial without ever revealing any extra information about the other coefficients.

## Finite Field Arithmetic

This implementation performs arithmetic in the finite field GF(PRIME), where  
`PRIME = 2^127 - 1` (i.e. 170141183460469231731687303715884105727).  
This choice is significant because:

- All operations are done modulo PRIME.
- The secret must be less than PRIME.
- Modular arithmetic is used for all computations (addition, multiplication, and inversion).

The module carefully implements modular multiplication using an iterative doubling algorithm to avoid overflow with u128 values. Modular inversion is performed using the Extended Euclidean Algorithm.

## Module Features

- **Generic k-out-of-n Sharing:**  
  The module supports splitting a secret into **n** shares with an arbitrary threshold **k**. For example:
  - **2/2 Sharing:** Both shares are required to reconstruct the secret.
  - **3/5 Sharing:** Any 3 out of 5 shares can be used to recover the secret.
  
  This generic approach makes the scheme highly flexible and suitable for a wide range of applications.

- **Core Functions:**
  - `split_secret(secret: u128, threshold: usize, share_count: usize) -> Vec<Share>`  
    Splits the given secret into the specified number of shares.
    
  - `combine_shares(shares: &[Share]) -> u128`  
    Reconstructs the secret from a collection of shares using Lagrange interpolation.


## How to Use This Module

### Splitting a Secret

To split a secret, you must provide:

- The secret (a u128 value less than PRIME).
- The threshold `k` (the minimum number of shares required to reconstruct the secret).
- The total number of shares to generate `n`.

Example:
```rust
use ronkathon::shamir::{split_secret, combine_shares};
let secret: u128 = 123456789;
let threshold = 3;
let share_count = 5;
let shares = split_secret(secret, threshold, share_count);
```


### Reconstructing a Secret

To recover the secret, supply a slice containing at least `k` shares:

```rust
// Assume shares is from the split_secret() function:
let required_shares = &shares[..threshold]; // Use any k shares
let recovered = combine_shares(required_shares);
assert_eq!(secret, recovered);
```

