# Shamir's Secret Sharing Scheme

Shamir's Secret Sharing (SSS) is a powerful cryptographic technique that divides a sensitive secret into multiple parts (shares), so that the secret can only be reconstructed when a minimum number of shares (the threshold) are combined. Fewer than the required number of shares reveal no useful information about the secret.

## Background and Theory

At its core, Shamir's scheme relies on the mathematical principle that a polynomial of degree (k - 1) is uniquely determined by k distinct points. The idea is to embed the secret as the constant term in a random polynomial:

 $P(x) = a_0 + a_1·x + a_2·x^2 + \cdots + a_{k-1}·x^{k-1}$

Here, $a_0$ represents the secret, and the subsequent coefficients $(a_1, a_2, \cdots, a_{k-1})$ are randomly chosen from a finite field. Each share is generated by evaluating the polynomial at a unique nonzero value of x (for example, x = 1, 2, …, n).  
Reconstruction is achieved using Lagrange interpolation, which recovers the polynomial—and thus the secret—from k shares.

## Finite Field Considerations

This implementation performs arithmetic in the finite field PlutoBaseField, where:

  $PRIME =101$

All arithmetic operations (addition, multiplication, inversion) are carried out in the PlutoBaseField. It is vital that the secret is a integer smaller than PRIME.

## Module Capabilities

The module provides a flexible API for generic k-out-of-n secret sharing, supporting both minimal cases (2-out-of-2 sharing) and more general configurations (e.g., 3-out-of-5 sharing). Specifically, the module offers:

- **Splitting the Secret:**  
  The function `split_secret(secret: u128, threshold: usize, share_count: usize) -> Vec<Share>` randomizes a polynomial with the secret as its constant term and outputs a set of shares, each represented as a tuple (x, P(x)). This allows for any chosen threshold and total share count.

- **Reconstructing the Secret:**  
  The function `combine_shares(shares: &[Share]) -> u128` uses Lagrange interpolation to recover the secret given any subset of shares whose length meets or exceeds the threshold.
## How to Use This Module

### Splitting a Secret

To generate shares from a secret, you specify the secret (a u128 number), the threshold (k), and the total number of desired shares (n):

```rust
use ronkathon::shamir::{split_secret, combine_shares};

let secret: u128 = 123456789;
let threshold = 3;
let share_count = 5;
let shares = split_secret<threshold>(secret, share_count);
```

### Reconstructing a Secret

Combine any subset of shares—provided the number meets or exceeds the threshold—to reconstruct the secret:

```rust
// Suppose we require 3 shares.
let required_shares = &shares[..threshold];
let recovered_secret = combine_shares(required_shares);
assert_eq!(secret, recovered_secret);
```

